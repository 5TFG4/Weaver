"""
Base Strategy Classes
Provides abstract base classes and data models for trading strategies.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Dict, Any, Optional, List


@dataclass
class StrategyConfig:
    """Configuration for a trading strategy"""
    name: str
    position_size: int
    symbols: List[str]
    enabled: bool = True
    parameters: Dict[str, Any] = field(default_factory=lambda: {})


@dataclass 
class StrategySignal:
    """Trading signal generated by a strategy"""
    action: str  # "buy" or "sell"
    symbol: str
    quantity: int
    reason: str
    strategy: str
    confidence: float = 1.0
    price_target: Optional[float] = None
    stop_loss: Optional[float] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for event publishing"""
        return {
            "action": self.action,
            "symbol": self.symbol,
            "quantity": self.quantity,
            "reason": self.reason,
            "strategy": self.strategy,
            "confidence": self.confidence,
            "price_target": self.price_target,
            "stop_loss": self.stop_loss
        }


class BaseStrategy(ABC):
    """Abstract base class for all trading strategies"""
    
    def __init__(self, config: StrategyConfig):
        self.config = config
        self.name = config.name
        self.enabled = config.enabled
        self.position_size = config.position_size
        self.symbols = config.symbols
        self.parameters = config.parameters
        
        # Strategy state
        self.last_prices: Dict[str, float] = {}
        self.positions: Dict[str, int] = {}
    
    @abstractmethod
    def analyze(self, market_data: Dict[str, Any]) -> Optional[StrategySignal]:
        """
        Analyze market data and generate trading signal
        
        Args:
            market_data: Market data dictionary for analysis
            
        Returns:
            StrategySignal if a trade signal is generated, None otherwise
        """
        pass
    
    def is_enabled(self) -> bool:
        """Check if strategy is enabled"""
        return self.enabled
    
    def should_trade_symbol(self, symbol: str) -> bool:
        """Check if strategy should trade this symbol"""
        return symbol in self.symbols
    
    def update_position(self, symbol: str, quantity: int, side: str) -> None:
        """Update position tracking for a symbol"""
        if symbol not in self.positions:
            self.positions[symbol] = 0
            
        if side == "buy":
            self.positions[symbol] += quantity
        else:  # sell
            self.positions[symbol] -= quantity
    
    def get_position(self, symbol: str) -> int:
        """Get current position for a symbol"""
        return self.positions.get(symbol, 0)
    
    def update_last_price(self, symbol: str, price: float) -> None:
        """Update the last known price for a symbol"""
        self.last_prices[symbol] = price
    
    def get_last_price(self, symbol: str) -> Optional[float]:
        """Get the last known price for a symbol"""
        return self.last_prices.get(symbol)
    
    def calculate_change_percent(self, symbol: str, current_price: float) -> float:
        """Calculate percentage change from last price"""
        last_price = self.get_last_price(symbol)
        if last_price is None:
            return 0.0
        return ((current_price - last_price) / last_price) * 100
    
    def get_strategy_info(self) -> Dict[str, Any]:
        """Get strategy information"""
        return {
            "name": self.name,
            "enabled": self.enabled,
            "symbols": self.symbols,
            "position_size": self.position_size,
            "positions": self.positions.copy(),
            "parameters": self.parameters.copy()
        }
